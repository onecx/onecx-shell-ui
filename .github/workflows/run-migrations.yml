name: Run Migrations

on:
  pull_request:
    types: [labeled, synchronize]

permissions:
  contents: write
  pull-requests: write

jobs:
  run-migrations:
    if: |
      (github.event.action == 'labeled' && (contains(github.event.label.name, 'nx-migration-required') || contains(github.event.label.name, 'onecx-migration-required'))) ||
      (github.event.action == 'synchronize' && github.event.pull_request.user.login == 'renovate[bot]' && (contains(github.event.pull_request.labels.*.name, 'nx-migration-required') || contains(github.event.pull_request.labels.*.name, 'onecx-migration-required')))
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          token: ${{ secrets.CI_PAT }}
          fetch-depth: 0

      - name: Check if migration already completed
        id: check-migration
        run: |
          # Check if the last commit was from migration workflow
          last_commit_message=$(gh pr view ${{ github.event.pull_request.number }} --json commits --jq '.commits[-1].messageHeadline')
          
          if [[ "$last_commit_message" == *"refactor: run package migrations per directory"* ]]; then
            echo "skip_migration=true" >> $GITHUB_OUTPUT
            echo "üö´ Last commit was migration, skipping to avoid infinite loop"
          else
            echo "skip_migration=false" >> $GITHUB_OUTPUT
            echo "‚úÖ No recent migration commit, proceeding with migration"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.CI_PAT }}

      - name: Setup Node.js
        if: steps.check-migration.outputs.skip_migration == 'false'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Extract changed packages per directory
        if: steps.check-migration.outputs.skip_migration == 'false'
        id: extract-packages
        run: |
          set -e
          
          # Ensure we have the base branch
          git fetch origin ${{ github.event.pull_request.base.ref }}:refs/remotes/origin/${{ github.event.pull_request.base.ref }}
          
          # Get the merge base
          merge_base=$(git merge-base HEAD origin/${{ github.event.pull_request.base.ref }})
          
          # Find all changed package.json files
          changed_files=$(git diff --name-only $merge_base...HEAD | grep package.json || true)
          
          echo "Changed package.json files: $changed_files"
          
          # Process each package.json file separately with its directory
          migration_commands=""
          if [[ -n "$changed_files" ]]; then
            for file in $changed_files; do
              if [[ -f "$file" ]]; then
                echo "Processing $file"
                
                # Get the directory of this package.json
                package_dir=$(dirname "$file")
                echo "Package directory: $package_dir"
                
                # Get old and new package.json content
                old_content=$(git show $merge_base:$file 2>/dev/null || echo '{}')
                new_content=$(cat "$file")
                
                # Extract changed packages for this specific package.json using Node.js
                file_migrations=$(node -e "
                  const oldPkg = JSON.parse(\`$old_content\`);
                  const newPkg = JSON.parse(\`$new_content\`);
                  
                  const oldDeps = { ...oldPkg.dependencies, ...oldPkg.devDependencies };
                  const newDeps = { ...newPkg.dependencies, ...newPkg.devDependencies };
                  
                  const migrations = [];
                  
                  // Check for ALL package updates with --from parameter
                  for (const [pkg, newVersion] of Object.entries(newDeps)) {
                    if (oldDeps[pkg] && oldDeps[pkg] !== newVersion) {
                      migrations.push(\`$package_dir:\${pkg}@\${newVersion} --from=\${pkg}@\${oldDeps[pkg]}\`);
                      console.error(\`Found update in $package_dir: \${pkg} from \${oldDeps[pkg]} to \${newVersion}\`);
                    }
                  }
                  
                  console.log(migrations.join('|'));
                ")
                
                if [[ -n "$file_migrations" ]]; then
                  if [[ -n "$migration_commands" ]]; then
                    migration_commands="$migration_commands|$file_migrations"
                  else
                    migration_commands="$file_migrations"
                  fi
                fi
              fi
            done
          fi
          
          echo "migration_commands=$migration_commands" >> $GITHUB_OUTPUT
          echo "Final migration commands to run: '$migration_commands'"

      - name: Run migrations per directory
        if: steps.check-migration.outputs.skip_migration == 'false' && steps.extract-packages.outputs.migration_commands != ''
        run: |
          set -e
          
          echo "=========================================="
          echo "üöÄ STARTING PACKAGE MIGRATIONS PER DIRECTORY"
          echo "=========================================="
          echo "Migration commands: ${{ steps.extract-packages.outputs.migration_commands }}"
          echo "=========================================="
          
          # Split migration commands by | and run each one in its directory
          IFS='|' read -ra MIGRATION_COMMANDS <<< "${{ steps.extract-packages.outputs.migration_commands }}"
          
          for cmd in "${MIGRATION_COMMANDS[@]}"; do
            if [[ -n "$cmd" && "$cmd" != " " ]]; then
              # Extract directory and migration command
              dir=$(echo "$cmd" | cut -d':' -f1)
              migration=$(echo "$cmd" | cut -d':' -f2-)
              
              echo ""
              echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
              echo "‚îÇ Running in directory: $dir"
              echo "‚îÇ Migration: nx migrate $migration"
              echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
              
              # Change to the package directory and run migration
              (
                cd "$dir" || { echo "‚ùå Failed to change to directory $dir"; continue; }
                
                echo "üìÇ Working directory: $(pwd)"
                
                # Install dependencies in this directory if package.json exists
                if [[ -f "package.json" ]]; then
                  echo "üì¶ Installing dependencies in $dir..."
                  npm ci || echo "‚ö†Ô∏è Failed to install dependencies in $dir, continuing..."
                fi
                
                echo "üîß Running migration: npx nx migrate $migration"
                npx nx migrate $migration || echo "‚ùå No migrations for '$migration' in $dir or migration failed"
                
                # Install any new dependencies from migrations
                if [[ -f "package.json" ]]; then
                  echo "üì¶ Installing new dependencies after migration..."
                  npm install || echo "‚ö†Ô∏è Failed to install new dependencies in $dir"
                fi
                
                # Run the actual migrations if they exist
                if [[ -f "migrations.json" ]]; then
                  echo "üîß Found migrations.json in $dir - executing migration scripts..."
                  npx nx migrate --run-migrations || echo "‚ùå No migrations to run in $dir"
                  echo "‚úÖ Migration scripts completed in $dir"
                else
                  echo "‚ÑπÔ∏è No migrations.json found in $dir"
                fi

                 # Install any new dependencies from migrations
                if [[ -f "package.json" ]]; then
                  echo "üì¶ Installing new dependencies after migration..."
                  npm install || echo "‚ö†Ô∏è Failed to install new dependencies in $dir"
                fi
              )
              
              echo "‚úÖ Completed migration in directory: $dir"
              echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            fi
          done
          
          echo ""
          echo "=========================================="
          echo "üéâ ALL DIRECTORY MIGRATIONS COMPLETED"
          echo "=========================================="

      - name: Commit all migration changes
        if: steps.check-migration.outputs.skip_migration == 'false'
        run: |
          git config --local user.email "29139614+renovate[bot]@users.noreply.github.com"
          git config --local user.name "renovate[bot]"
          
          if [[ -n "$(git status --porcelain)" ]]; then
            echo ""
            echo "=========================================="
            echo "üìù COMMITTING SELECTIVE MIGRATION CHANGES"
            echo "=========================================="
            
            echo "All changed files:"
            git status --porcelain
            
            echo ""
            echo "üîç Analyzing changes for selective commit..."
            
            # Add all non-lock files first
            echo "üì¶ Adding all non-package-lock.json files..."
            git add . --verbose
            
            # Reset package-lock.json files that don't have corresponding package.json changes
            echo "üîç Checking package-lock.json files..."
            
            # Find all package-lock.json files that were changed
            changed_lock_files=$(git diff --cached --name-only | grep "package-lock.json" || true)
            
            for lock_file in $changed_lock_files; do
              # Get the directory of the lock file
              lock_dir=$(dirname "$lock_file")
              corresponding_package_json="$lock_dir/package.json"
              
              echo "Checking: $lock_file"
              echo "Corresponding package.json: $corresponding_package_json"
              
              # Check if the corresponding package.json was also changed
              if git diff --cached --name-only | grep -q "^$corresponding_package_json$"; then
                echo "‚úÖ $corresponding_package_json was changed - keeping $lock_file"
              else
                echo "‚ùå $corresponding_package_json was NOT changed - removing $lock_file from commit"
                git reset HEAD "$lock_file"
                git checkout -- "$lock_file"  # Restore original lock file
              fi
            done
            
            echo ""
            echo "üìã Final files to be committed:"
            git diff --cached --name-only
            
            # Try to pull and merge, but prioritize our migration changes
            echo "üì• Pulling remote changes (migration changes will win conflicts)..."
            git pull origin ${{ github.event.pull_request.head.ref }} --strategy-option=ours || {
              echo "‚ö†Ô∏è Pull failed, forcing our migration changes..."
              
              # If pull fails, commit our changes first
              if [[ -n "$(git diff --cached --name-only)" ]]; then
                git commit --no-verify -m "refactor: run package migrations per directory

                Auto-generated by GitHub Actions after dependency updates.
                Migrations run in their respective package directories for proper context.

                Co-authored-by: renovate[bot] <29139614+renovate[bot]@users.noreply.github.com>" || echo "Nothing to commit"
              fi
              
              # Then handle merge conflicts
              git fetch origin ${{ github.event.pull_request.head.ref }}
              git merge origin/${{ github.event.pull_request.head.ref }} -X ours --no-edit || {
                echo "üîß Merge conflicts, using reset approach..."
                git reset --soft HEAD~1
                git reset --hard origin/${{ github.event.pull_request.head.ref }}
                
                # Re-run selective add after reset
                git add . --verbose
                for lock_file in $(git diff --cached --name-only | grep "package-lock.json" || true); do
                  lock_dir=$(dirname "$lock_file")
                  corresponding_package_json="$lock_dir/package.json"
                  if ! git diff --cached --name-only | grep -q "^$corresponding_package_json$"; then
                    git reset HEAD "$lock_file"
                    git checkout -- "$lock_file"
                  fi
                done
              }
            }
            
            # Final commit if there are still staged changes
            if [[ -n "$(git diff --cached --name-only)" ]]; then
              git commit --no-verify -m "refactor: run package migrations per directory

              Auto-generated by GitHub Actions after dependency updates.
              Migrations run in their respective package directories for proper context.

              Co-authored-by: renovate[bot] <29139614+renovate[bot]@users.noreply.github.com>"
            fi
            
            # Force push to ensure our changes are applied
            echo "üöÄ Force pushing migration changes..."
            git push --force-with-lease origin HEAD:${{ github.event.pull_request.head.ref }}
            
            echo "‚úÖ Selective migration changes committed and pushed"
            echo "üìã Labels kept for future rebases"
            echo "=========================================="
          else
            # No local changes, just try to pull
            echo "üì• No local changes, pulling remote updates..."
            git pull origin ${{ github.event.pull_request.head.ref }} || echo "No remote changes to pull or pull failed"
            
            echo ""
            echo "=========================================="
            echo "‚ÑπÔ∏è NO MIGRATION CHANGES TO COMMIT"
            echo "=========================================="
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.CI_PAT }}